{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Azure Functions Doctor \ud83e\ude7a","text":"<p>Azure Functions Doctor is a CLI tool to validate and diagnose your Python Azure Functions environment.</p>"},{"location":"#key-features","title":"\ud83d\udd0d Key Features","text":"<ul> <li>\ud83d\udc0d Diagnose Python version and virtual environment</li> <li>\ud83d\udcc1 Validate Azure Functions project structure (<code>host.json</code>, <code>function.json</code>)</li> <li>\ud83d\udca1 Developer-friendly output with emoji indicators</li> <li>\u2705 Supports formatting, linting, typing, test coverage, and automated releases</li> </ul>"},{"location":"api/","title":"\ud83e\udde0 API Reference","text":""},{"location":"api/#cli","title":"CLI","text":""},{"location":"api/#azure_functions_doctor.cli.diagnose","title":"<code>diagnose(path='.', verbose=False, format='table', output=None)</code>","text":"<p>Run diagnostics on an Azure Functions application.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Azure Functions app. Defaults to current directory.</p> <code>'.'</code> <code>verbose</code> <code>bool</code> <p>Show detailed hints for failed checks.</p> <code>False</code> <code>format</code> <code>Annotated[str, Option(help=\"Output format: 'table' or 'json'\")]</code> <p>Output format: 'table' or 'json'.</p> <code>'table'</code> <code>output</code> <code>Annotated[Optional[Path], Option(help='Optional path to save JSON result')]</code> <p>Optional file path to save JSON result.</p> <code>None</code> Source code in <code>src/azure_functions_doctor/cli.py</code> <pre><code>@cli.command()\ndef diagnose(\n    path: str = \".\",\n    verbose: bool = False,\n    format: Annotated[str, typer.Option(help=\"Output format: 'table' or 'json'\")] = \"table\",\n    output: Annotated[Optional[Path], typer.Option(help=\"Optional path to save JSON result\")] = None,\n) -&gt; None:\n    \"\"\"\n    Run diagnostics on an Azure Functions application.\n\n    Args:\n        path: Path to the Azure Functions app. Defaults to current directory.\n        verbose: Show detailed hints for failed checks.\n        format: Output format: 'table' or 'json'.\n        output: Optional file path to save JSON result.\n    \"\"\"\n    doctor = Doctor(path)\n    results = doctor.run_all_checks()\n\n    passed = failed = 0\n\n    if format == \"json\":\n        import json\n\n        json_output = results  # Already a list of dictionaries\n        console.print_json(data=json_output)\n\n        if output:\n            output.write_text(json.dumps(json_output, indent=2))\n            console.print(f\"[green]\u2713 JSON output written to:[/green] {output}\")\n        return\n\n    # Default: table format\n    for section in results:\n        # Section header with icon and bold title\n        console.print(Text.assemble(\"\\n\", format_result(section[\"status\"]), \" \", (section[\"title\"], \"bold\")))\n\n        if section[\"status\"] == \"pass\":\n            passed += 1\n        else:\n            failed += 1\n\n        for item in section[\"items\"]:\n            status = item[\"status\"]\n            label = item[\"label\"]\n            value = item[\"value\"]\n\n            line = Text.assemble((\"  \u2022 \", \"default\"), (label, \"dim\"), (\": \", \"default\"), format_detail(status, value))\n            console.print(line)\n\n            if verbose and status != \"pass\":\n                if item.get(\"hint\"):\n                    console.print(f\"    \u21aa {item['hint']}\")\n                if item.get(\"doc\"):\n                    console.print(f\"    \ud83d\udcda {item['doc']}\")\n\n    # Summary section\n    console.print()\n    console.rule(\"[bold]Summary\")\n    summary = Text.assemble(\n        (f\"{format_status_icon('pass')} \", \"green\"),\n        f\"{passed} Passed    \",\n        (f\"{format_status_icon('fail')} \", \"red\"),\n        f\"{failed} Failed\",\n    )\n    console.print(summary)\n</code></pre>"},{"location":"api/#doctor","title":"Doctor","text":""},{"location":"api/#azure_functions_doctor.doctor.Doctor","title":"<code>Doctor(path='.')</code>","text":"<p>Diagnostic runner for Azure Functions apps. Loads checks from rules.json and executes them against a target project path.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def __init__(self, path: str = \".\") -&gt; None:\n    self.project_path: Path = Path(path).resolve()\n    self.rules_path: Path = Path(__file__).parent / \"rules.json\"\n</code></pre>"},{"location":"api/#azure_functions_doctor.doctor.Doctor.run_all_checks","title":"<code>run_all_checks()</code>","text":"<p>Load rules from rules.json, group them by section, and run each rule through the generic handler.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>A list of section results with grouped check outcomes.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def run_all_checks(self) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Load rules from rules.json, group them by section,\n    and run each rule through the generic handler.\n\n    Returns:\n        A list of section results with grouped check outcomes.\n    \"\"\"\n    with self.rules_path.open(encoding=\"utf-8\") as f:\n        rules: list[dict[str, Any]] = json.load(f)\n\n    grouped: dict[str, list[dict[str, Any]]] = defaultdict(list)\n    for rule in rules:\n        grouped[rule[\"section\"]].append(rule)\n\n    results = []\n\n    for section, checks in grouped.items():\n        section_result: dict[str, Any] = {\n            \"title\": section.replace(\"_\", \" \").title(),\n            \"category\": section,\n            \"status\": \"pass\",\n            \"items\": [],\n        }\n\n        for rule in checks:\n            # Cast rule to TypedDict to satisfy mypy\n            typed_rule = cast(Rule, rule)\n            result = generic_handler(typed_rule, self.project_path)\n\n            item = {\n                \"label\": typed_rule.get(\"label\", typed_rule[\"id\"]),\n                \"value\": result[\"detail\"],\n                \"status\": result[\"status\"],\n            }\n\n            if result[\"status\"] != \"pass\":\n                section_result[\"status\"] = \"fail\"\n\n            if \"hint\" in typed_rule:\n                item[\"hint\"] = typed_rule[\"hint\"]\n\n            section_result[\"items\"].append(item)\n\n        results.append(section_result)\n\n    return results\n</code></pre>"},{"location":"api/#handlers","title":"Handlers","text":""},{"location":"api/#azure_functions_doctor.handlers.Rule","title":"<code>Rule</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A typed dictionary representing a diagnostic rule from rules.json. Each field is optional and depends on the check type.</p>"},{"location":"api/#azure_functions_doctor.handlers.generic_handler","title":"<code>generic_handler(rule, path)</code>","text":"<p>Dispatch and execute a generic diagnostic rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Rule</code> <p>A Rule dictionary containing check type and parameters.</p> required <code>path</code> <code>Path</code> <p>Base path of the Azure Functions project.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with: - 'status': 'pass' or 'fail' - 'detail': explanation of the result</p> Source code in <code>src/azure_functions_doctor/handlers.py</code> <pre><code>def generic_handler(rule: Rule, path: Path) -&gt; dict[str, str]:\n    \"\"\"\n    Dispatch and execute a generic diagnostic rule.\n\n    Args:\n        rule: A Rule dictionary containing check type and parameters.\n        path: Base path of the Azure Functions project.\n\n    Returns:\n        A dictionary with:\n            - 'status': 'pass' or 'fail'\n            - 'detail': explanation of the result\n    \"\"\"\n    check_type = rule.get(\"type\", \"\")\n\n    if check_type == \"compare_version\":\n        # Compare system Python version to expected\n        expected = rule[\"value\"]\n        operator = rule[\"operator\"]\n        current_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n        current = parse_version(current_version)\n        expected_v = parse_version(expected)\n\n        passed = {\n            \"&gt;=\": current &gt;= expected_v,\n            \"&lt;=\": current &lt;= expected_v,\n            \"==\": current == expected_v,\n            \"&gt;\": current &gt; expected_v,\n            \"&lt;\": current &lt; expected_v,\n        }.get(operator, False)\n\n        return {\n            \"status\": \"pass\" if passed else \"fail\",\n            \"detail\": f\"Current: {current_version}, Expected: {operator}{expected}\",\n        }\n\n    if check_type == \"env_var_exists\":\n        # Check if environment variable is set\n        var = rule[\"var\"]\n        exists = os.getenv(var) is not None\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{var} is {'set' if exists else 'not set'}\",\n        }\n\n    if check_type == \"path_exists\":\n        # Check if a specific path exists (can be sys.executable or relative)\n        target = rule[\"target\"]\n        target_path = sys.executable if target == \"sys.executable\" else os.path.join(path, target)\n        exists = os.path.exists(target_path)\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{target_path} {'exists' if exists else 'is missing'}\",\n        }\n\n    if check_type == \"file_exists\":\n        # Check if a file exists relative to the base path\n        target = os.path.join(path, rule[\"target\"])\n        exists = os.path.isfile(target)\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{target} {'exists' if exists else 'is missing'}\",\n        }\n\n    if check_type == \"package_installed\":\n        # Check if a Python package is importable\n        package_name = rule[\"target\"]\n        found = importlib.util.find_spec(package_name) is not None\n        return {\n            \"status\": \"pass\" if found else \"fail\",\n            \"detail\": f\"{package_name} is {'installed' if found else 'not installed'}\",\n        }\n\n    return {\n        \"status\": \"fail\",\n        \"detail\": f\"Unsupported check type: {check_type}\",\n    }\n</code></pre>"},{"location":"api/#check-logic","title":"Check Logic","text":""},{"location":"api/#azure_functions_doctor.check.run_check","title":"<code>run_check(rule, base_path)</code>","text":"<p>Wrap the generic_handler to cast a raw rule into a typed Rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>dict[str, Any]</code> <p>Dictionary parsed from rules.json</p> required <code>base_path</code> <code>Path</code> <p>Path to Azure Functions app</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Structured result with status, label, value, and optional hint.</p> Source code in <code>src/azure_functions_doctor/check.py</code> <pre><code>def run_check(rule: dict[str, Any], base_path: Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Wrap the generic_handler to cast a raw rule into a typed Rule.\n\n    Args:\n        rule: Dictionary parsed from rules.json\n        base_path: Path to Azure Functions app\n\n    Returns:\n        Structured result with status, label, value, and optional hint.\n    \"\"\"\n    result = generic_handler(cast(Rule, rule), base_path)\n\n    return {\n        \"status\": result[\"status\"],\n        \"label\": rule.get(\"label\", rule.get(\"id\")),\n        \"value\": result[\"detail\"],\n        \"hint\": rule.get(\"hint\"),\n    }\n</code></pre>"},{"location":"api/#target-resolver","title":"Target Resolver","text":""},{"location":"api/#azure_functions_doctor.target_resolver.resolve_target_value","title":"<code>resolve_target_value(target)</code>","text":"<p>Resolve the current value of a target used in version comparison or diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representing the resolved version or value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target is not recognized.</p> Source code in <code>src/azure_functions_doctor/target_resolver.py</code> <pre><code>def resolve_target_value(target: str) -&gt; str:\n    \"\"\"\n    Resolve the current value of a target used in version comparison or diagnostics.\n\n    Args:\n        target: The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".\n\n    Returns:\n        A string representing the resolved version or value.\n\n    Raises:\n        ValueError: If the target is not recognized.\n    \"\"\"\n    if target == \"python\":\n        return sys.version.split()[0]\n    if target == \"func_core_tools\":\n        try:\n            output = subprocess.check_output([\"func\", \"--version\"], text=True)\n            return output.strip()\n        except Exception:\n            return \"0.0.0\"  # Return a fallback version if resolution fails\n    raise ValueError(f\"Unknown target: {target}\")\n</code></pre>"},{"location":"api/#utility","title":"Utility","text":""},{"location":"api/#azure_functions_doctor.utils.format_detail","title":"<code>format_detail(status, value)</code>","text":"<p>Return a colored Text element based on status and value.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <code>value</code> <code>str</code> <p>Text to display, typically a description.</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object styled with status color.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_detail(status: str, value: str) -&gt; Text:\n    \"\"\"\n    Return a colored Text element based on status and value.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n        value: Text to display, typically a description.\n\n    Returns:\n        A Rich Text object styled with status color.\n    \"\"\"\n    color = DETAIL_COLOR_MAP.get(status, \"white\")\n    return Text(value, style=color)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_result","title":"<code>format_result(status)</code>","text":"<p>Return a styled icon Text element based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object with icon and style for headers.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_result(status: str) -&gt; Text:\n    \"\"\"\n    Return a styled icon Text element based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A Rich Text object with icon and style for headers.\n    \"\"\"\n    style = STATUS_STYLES.get(status, Style(color=\"white\"))\n    icon = format_status_icon(status)\n    return Text(icon, style=style)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_status_icon","title":"<code>format_status_icon(status)</code>","text":"<p>Return a simple icon character based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string icon such as \u2714, \u2716, or \u26a0.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_status_icon(status: str) -&gt; str:\n    \"\"\"\n    Return a simple icon character based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A string icon such as \u2714, \u2716, or \u26a0.\n    \"\"\"\n    return STATUS_ICONS.get(status, \"?\")\n</code></pre>"},{"location":"development/","title":"\ud83d\udee0\ufe0f Development Guide (Hatch-based)","text":"<p>This project uses Hatch as its build and environment manager.</p>"},{"location":"development/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.9+</li> <li>Git</li> <li>Recommended: <code>uv</code> for fast dependency management</li> </ul>"},{"location":"development/#setup","title":"\ud83d\ude80 Setup","text":"<pre><code>make venv               # Create virtual environment\nmake install            # Install dependencies using Hatch\nmake precommit-install  # Install pre-commit hooks\n</code></pre>"},{"location":"development/#local-testing","title":"\ud83e\uddea Local Testing","text":"<pre><code>make check         # Format, lint, typecheck, test\nmake test          # Run unit tests\nmake cov           # Generate test coverage report\n</code></pre>"},{"location":"development/#release-workflow","title":"\ud83d\udea2 Release Workflow","text":"<pre><code>make release-patch   # Patch version bump + changelog update\nmake release-minor   # Minor version bump + changelog update\nmake release-major   # Major version bump + changelog update\nmake publish         # Publish to PyPI (requires credentials)\n</code></pre>"},{"location":"development/#code-quality-commands","title":"\ud83e\uddf9 Code Quality Commands","text":"<pre><code>make format      # Format code with Black + Ruff\nmake lint        # Run Ruff + Mypy\nmake typecheck   # Run static type checks\nmake docs        # Serve local MkDocs site\n</code></pre>"},{"location":"diagnostics/","title":"Diagnostic Checks","text":"<p>This document lists potential diagnostic features for Azure Functions Doctor, based on Azure Functions Python Reference and Azure Functions Best Practices. </p> # Diagnostic Check Description Feasibility Status 1 Python version \u2265 3.9 Check if the runtime meets minimum requirements \u2705 Easy \u2705 Implemented 2 Virtual environment (.venv) exists Ensure isolation of dependencies \u2705 Easy \u2705 Implemented 3 Azure Functions Core Tools installed Validate that <code>func</code> CLI is available \u2705 Easy \u2705 Implemented 4 host.json exists and is valid Ensure configuration file is present \u2705 Easy \u2705 Implemented 5 function.json exists per function Ensure each function folder has its own function.json \u2705 Easy \u2705 Implemented 6 Directory structure validation Check if directory matches Azure Functions layout \u2705 Easy \u2705 Implemented 7 requirements.txt or pyproject.toml present Check for dependency file \u2705 Easy \ud83d\udd27 Planned 8 local.settings.json exists Verify local dev settings file exists \u2705 Easy \ud83d\udd27 Planned 9 EntryPoint function exists Ensure the entryPoint in function.json matches a real Python function \u2705 Easy \ud83d\udd27 Planned 10 Function name and folder match Ensure function directory and entryPoint are aligned \u2705 Easy \ud83d\udd27 Planned 11 Durable Functions config in host.json Detect durableTask section for durable functions \u2705 Medium \ud83d\udd27 Planned 12 HTTP trigger config validation Validate authLevel, route, and methods \u2705 Medium \ud83d\udd27 Planned 13 Timer trigger CRON expression validation Check CRON format in bindings \u2705 Medium \ud83d\udd27 Planned 14 App Insights configuration Validate instrumentation key or connection string \u2705 Medium \ud83d\udd27 Planned 15 Function mode detection (decorator or json) Detect whether function app uses decorators or function.json model \u2705 Medium \ud83d\udd27 Planned 16 ASGI/WSGI compatibility Check if the app exposes ASGI/WSGI interfaces \u2705 Medium \ud83d\udd27 Planned 17 Detect unused or invalid files Warn about <code>.pyc</code>, <code>__pycache__</code>, or other irrelevant files \u2705 Low \ud83e\udded Possible 18 Detect long-running code patterns Flag suspicious code like <code>time.sleep</code> or infinite loops \u274c Hard \u274c Not feasible 19 Excessive logging Identify overuse of <code>print()</code> or <code>logging.debug()</code> \u274c Runtime \u274c Not feasible 20 Monolith vs modular layout Warn if everything is in one file or single large function \u274c Context \u274c Not feasible <p>Legend: \u2705 Easy = statically checkable \u2705 Medium = requires additional parsing/context \u274c = not feasible by static analysis \ud83d\udd27 Planned = scheduled for future implementation \ud83e\udded Possible = technically feasible but lower priority</p>"},{"location":"usage/","title":"\ud83d\udda5\ufe0f CLI Usage: Azure Functions Doctor","text":"<p>Azure Functions Doctor provides a CLI to help validate and troubleshoot your Python Azure Functions project.</p>"},{"location":"usage/#basic-usage","title":"\ud83d\udd27 Basic Usage","text":"<p>Run the CLI from your terminal:</p> <pre><code>hatch run azfunc-doctor\n</code></pre> <p>This will display the help menu and available commands.</p> <p>Or alternatively:</p> <pre><code>python -m azure_functions_doctor.cli\n</code></pre>"},{"location":"usage/#run-diagnostics","title":"\ud83e\ude7a Run Diagnostics","text":"<p>To check your local Azure Functions setup:</p> <pre><code>hatch run azfunc-doctor diagnose\n</code></pre> <p>You can also specify options:</p> <pre><code>hatch run azfunc-doctor diagnose --format json --verbose\n</code></pre>"},{"location":"usage/#what-it-checks","title":"What It Checks:","text":"<ul> <li>\u2705 Python version is \u2265 3.9</li> <li>\u2705 <code>.venv</code> directory exists</li> <li>\u2705 Azure Functions Core Tools (<code>func</code>) is installed</li> <li>\u2705 <code>host.json</code> and <code>function.json</code> are valid</li> <li>\u2705 Expected directory structure is present</li> <li>\u26a0\ufe0f Optional files like <code>requirements.txt</code> (future support)</li> </ul>"},{"location":"usage/#help","title":"\ud83c\udd98 Help","text":"<p>To view available options and subcommands:</p> <pre><code>hatch run azfunc-doctor --help\nhatch run azfunc-doctor diagnose --help\n</code></pre>"},{"location":"usage/#example-output","title":"\ud83d\udca1 Example Output","text":"<pre><code>$ azfunc-doctor diagnose\n\n\u2716 Python Environment\n  \u2022 Python version: Current: 3.12.3, Expected: &gt;=3.9\n  \u2022 Virtual environment: VIRTUAL_ENV is set\n  \u2022 Python executable: /root/.local/share/hatch/env/virtual/azure-function-doctor/qaLwoID5/azure-function-doctor/bin/python exists\n  \u2022 requirements.txt: /root/Github/azure-functions-doctor/examples/basic-hello/requirements.txt exists\n  \u2022 azure-functions package: azure_functions is not installed\n\n\u2716 Project Structure\n  \u2022 host.json: /root/Github/azure-functions-doctor/examples/basic-hello/host.json exists\n  \u2022 local.settings.json: /root/Github/azure-functions-doctor/examples/basic-hello/local.settings.json is missing\n  \u2022 main.py: /root/Github/azure-functions-doctor/examples/basic-hello/main.py is missing\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Summary \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2714 0 Passed    \u2716 2 Failed\n</code></pre>"}]}