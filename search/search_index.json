{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Azure Functions Doctor \ud83e\ude7a\u26a1","text":"<p>Azure Functions Doctor is a Python-based CLI tool that diagnoses and validates your local Azure Functions environment. It helps identify common issues such as missing files, version mismatches, or misconfigurations in your project setup.</p>"},{"location":"#why-use-this-tool","title":"\ud83d\udd0d Why Use This Tool?","text":"<ul> <li>\u2705 You're getting random 500 errors and suspect a misconfigured environment?</li> <li>\u2705 You want to sanity-check your project before deploying to Azure?</li> <li>\u2705 You prefer structured output over guesswork?</li> </ul> <p>Let Azure Functions Doctor help you save time and debug faster.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>\ud83d\udc0d Diagnose Python version, virtual environment, and dependencies</li> <li>\ud83d\udcc1 Validate Azure Functions project structure (<code>host.json</code>, <code>function.json</code>, <code>main.py</code>, etc.)</li> <li>\ud83d\udce6 Check if required packages (like <code>azure-functions</code>) are installed</li> <li>\ud83d\udcc4 Validate presence of config files like <code>requirements.txt</code> and <code>local.settings.json</code></li> <li>\ud83d\udca1 Developer-friendly output with emoji indicators and summary section</li> <li>\ud83d\udee0 Easily extendable via <code>rules.json</code> and handler functions</li> </ul>"},{"location":"api/","title":"\ud83e\udde0 API Reference","text":""},{"location":"api/#cli","title":"CLI","text":""},{"location":"api/#azure_functions_doctor.cli.diagnose","title":"<code>diagnose(path='.', verbose=False, format='table', output=None)</code>","text":"<p>Run diagnostics on an Azure Functions application.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Azure Functions app. Defaults to current directory.</p> <code>'.'</code> <code>verbose</code> <code>bool</code> <p>Show detailed hints for failed checks.</p> <code>False</code> <code>format</code> <code>Annotated[str, Option(help=\"Output format: 'table' or 'json'\")]</code> <p>Output format: 'table' or 'json'.</p> <code>'table'</code> <code>output</code> <code>Annotated[Optional[Path], Option(help='Optional path to save JSON result')]</code> <p>Optional file path to save JSON result.</p> <code>None</code> Source code in <code>src/azure_functions_doctor/cli.py</code> <pre><code>@cli.command()\ndef diagnose(\n    path: str = \".\",\n    verbose: bool = False,\n    format: Annotated[str, typer.Option(help=\"Output format: 'table' or 'json'\")] = \"table\",\n    output: Annotated[Optional[Path], typer.Option(help=\"Optional path to save JSON result\")] = None,\n) -&gt; None:\n    \"\"\"\n    Run diagnostics on an Azure Functions application.\n\n    Args:\n        path: Path to the Azure Functions app. Defaults to current directory.\n        verbose: Show detailed hints for failed checks.\n        format: Output format: 'table' or 'json'.\n        output: Optional file path to save JSON result.\n    \"\"\"\n    doctor = Doctor(path)\n    results = doctor.run_all_checks()\n\n    passed = failed = 0\n\n    if format == \"json\":\n        import json\n\n        json_output = results\n\n        if output:\n            output.parent.mkdir(parents=True, exist_ok=True)\n            output.write_text(json.dumps(json_output, indent=2), encoding=\"utf-8\")\n            console.print(f\"[green]\u2713 JSON output saved to:[/green] {output}\")\n        else:\n            print(json.dumps(json_output, indent=2))\n        return\n\n    # Print header only for table format\n    console.print(f\"[bold blue]\ud83e\ude7a Azure Functions Doctor for Python v{__version__}[/bold blue]\")\n    console.print(f\"[bold]\ud83d\udcc1 Path:[/bold] {Path(path).resolve()}\\n\")\n\n    # Default: table format\n    for section in results:\n        console.print(Text.assemble(\"\\n\", format_result(section[\"status\"]), \" \", (section[\"title\"], \"bold\")))\n\n        if section[\"status\"] == \"pass\":\n            passed += 1\n        else:\n            failed += 1\n\n        for item in section[\"items\"]:\n            label = item[\"label\"]\n            value = item[\"value\"]\n            status = item[\"status\"]\n\n            line = Text.assemble(\n                (\"  \u2022 \", \"default\"),\n                (label, \"dim\"),\n                (\": \", \"default\"),\n                format_detail(status, value),\n            )\n            console.print(line)\n\n            if verbose and status != \"pass\":\n                if item.get(\"hint\"):\n                    console.print(f\"    \u21aa [yellow]{item['hint']}[/yellow]\")\n                hint_url = item.get(\"hint_url\", \"\")\n                if hint_url.strip():\n                    console.print(f\"    \ud83d\udcda [blue]{hint_url}[/blue]\")\n\n    # \u2705 Summary section\n    console.print()\n    console.print(\"[bold]Summary[/bold]\")\n    summary = Text.assemble(\n        (f\"{format_status_icon('pass')} \", \"green bold\"),\n        (f\"{passed} Passed    \", \"bold\"),\n        (f\"{format_status_icon('fail')} \", \"red bold\"),\n        (f\"{failed} Failed\", \"bold\"),\n    )\n    console.print(summary)\n</code></pre>"},{"location":"api/#doctor","title":"Doctor","text":""},{"location":"api/#azure_functions_doctor.doctor.Doctor","title":"<code>Doctor(path='.')</code>","text":"<p>Diagnostic runner for Azure Functions apps. Loads checks from rules.json and executes them against a target project path.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def __init__(self, path: str = \".\") -&gt; None:\n    self.project_path: Path = Path(path).resolve()\n    self.rules_path: Path = self.project_path / \"rules.json\"\n</code></pre>"},{"location":"api/#azure_functions_doctor.doctor.Doctor.run_all_checks","title":"<code>run_all_checks()</code>","text":"<p>Run all rules grouped by their section. Each section will include pass/fail status and individual check items.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def run_all_checks(self) -&gt; list[SectionResult]:\n    \"\"\"\n    Run all rules grouped by their section.\n    Each section will include pass/fail status and individual check items.\n    \"\"\"\n    rules = self.load_rules()\n    grouped: dict[str, list[Rule]] = defaultdict(list)\n\n    for rule in rules:\n        grouped[rule[\"section\"]].append(rule)\n\n    results: list[SectionResult] = []\n\n    for section, checks in grouped.items():\n        section_result: SectionResult = {\n            \"title\": section.replace(\"_\", \" \").title(),\n            \"category\": section,\n            \"status\": \"pass\",\n            \"items\": [],\n        }\n\n        for rule in checks:\n            result = generic_handler(rule, self.project_path)\n\n            item: CheckResult = {\n                \"label\": rule.get(\"label\", rule[\"id\"]),\n                \"value\": result[\"detail\"],\n                \"status\": result[\"status\"],\n            }\n\n            if result[\"status\"] != \"pass\":\n                section_result[\"status\"] = \"fail\"\n\n            if \"hint\" in rule:\n                item[\"hint\"] = rule[\"hint\"]\n\n            if \"hint_url\" in rule and rule[\"hint_url\"]:\n                item[\"hint_url\"] = rule[\"hint_url\"]\n\n            section_result[\"items\"].append(item)\n\n        results.append(section_result)\n\n    return results\n</code></pre>"},{"location":"api/#handlers","title":"Handlers","text":""},{"location":"api/#azure_functions_doctor.handlers.generic_handler","title":"<code>generic_handler(rule, path)</code>","text":"<p>Execute a diagnostic rule based on its type and condition.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Rule</code> <p>The rule dictionary.</p> required <code>path</code> <code>Path</code> <p>Path to the Azure Functions project.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A result dict with status ('pass' or 'fail') and detail message.</p> Source code in <code>src/azure_functions_doctor/handlers.py</code> <pre><code>def generic_handler(rule: Rule, path: Path) -&gt; dict[str, str]:\n    \"\"\"\n    Execute a diagnostic rule based on its type and condition.\n\n    Args:\n        rule: The rule dictionary.\n        path: Path to the Azure Functions project.\n\n    Returns:\n        A result dict with status ('pass' or 'fail') and detail message.\n    \"\"\"\n    check_type = rule.get(\"type\")\n    condition = rule.get(\"condition\", {})\n\n    target = condition.get(\"target\")\n    operator = condition.get(\"operator\")\n    value = condition.get(\"value\")\n\n    if check_type == \"compare_version\":\n        if not (target and operator and value):\n            return {\"status\": \"fail\", \"detail\": \"Missing condition fields for compare_version\"}\n\n        if target == \"python\":\n            current_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n            current = parse_version(current_version)\n            expected = parse_version(str(value))\n\n            passed = {\n                \"&gt;=\": current &gt;= expected,\n                \"&lt;=\": current &lt;= expected,\n                \"==\": current == expected,\n                \"&gt;\": current &gt; expected,\n                \"&lt;\": current &lt; expected,\n            }.get(operator, False)\n\n            return {\n                \"status\": \"pass\" if passed else \"fail\",\n                \"detail\": f\"Python version is {current_version}, expected {operator}{value}\",\n            }\n\n        return {\"status\": \"fail\", \"detail\": f\"Unknown target for version comparison: {target}\"}\n\n    elif check_type == \"env_var_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing environment variable name\"}\n        exists = os.getenv(target) is not None\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{target} is {'set' if exists else 'not set'}\",\n        }\n\n    elif check_type == \"path_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing target path\"}\n        resolved_path = sys.executable if target == \"sys.executable\" else os.path.join(path, target)\n        exists = os.path.exists(resolved_path)\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{resolved_path} {'exists' if exists else 'is missing'}\",\n        }\n\n    elif check_type == \"file_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing file path\"}\n        file_path = os.path.join(path, target)\n        exists = os.path.isfile(file_path)\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{file_path} {'exists' if exists else 'is missing'}\",\n        }\n\n    elif check_type == \"package_installed\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing package name\"}\n        found = importlib.util.find_spec(target) is not None\n        return {\n            \"status\": \"pass\" if found else \"fail\",\n            \"detail\": f\"Package '{target}' is {'installed' if found else 'not installed'}\",\n        }\n\n    return {\n        \"status\": \"fail\",\n        \"detail\": f\"Unsupported check type: {check_type}\",\n    }\n</code></pre>"},{"location":"api/#check-logic","title":"Check Logic","text":""},{"location":"api/#azure_functions_doctor.check.run_check","title":"<code>run_check(rule, base_path)</code>","text":"<p>Wrap the generic_handler to cast a raw rule into a typed Rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>dict[str, Any]</code> <p>Dictionary parsed from rules.json</p> required <code>base_path</code> <code>Path</code> <p>Path to Azure Functions app</p> required <p>Returns:</p> Type Description <code>CheckResult</code> <p>Structured result with status, label, value, and optional hint.</p> Source code in <code>src/azure_functions_doctor/check.py</code> <pre><code>def run_check(rule: dict[str, Any], base_path: Path) -&gt; CheckResult:\n    \"\"\"\n    Wrap the generic_handler to cast a raw rule into a typed Rule.\n\n    Args:\n        rule: Dictionary parsed from rules.json\n        base_path: Path to Azure Functions app\n\n    Returns:\n        Structured result with status, label, value, and optional hint.\n    \"\"\"\n    typed_rule = cast(Rule, rule)\n    result = generic_handler(typed_rule, base_path)\n\n    output: CheckResult = {\n        \"status\": result[\"status\"],\n        \"label\": typed_rule.get(\"label\", typed_rule[\"id\"]),\n        \"value\": result[\"detail\"],\n    }\n\n    if \"hint\" in typed_rule:\n        output[\"hint\"] = typed_rule[\"hint\"]\n\n    return output\n</code></pre>"},{"location":"api/#target-resolver","title":"Target Resolver","text":""},{"location":"api/#azure_functions_doctor.target_resolver.resolve_target_value","title":"<code>resolve_target_value(target)</code>","text":"<p>Resolve the current value of a target used in version comparison or diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representing the resolved version or value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target is not recognized.</p> Source code in <code>src/azure_functions_doctor/target_resolver.py</code> <pre><code>def resolve_target_value(target: str) -&gt; str:\n    \"\"\"\n    Resolve the current value of a target used in version comparison or diagnostics.\n\n    Args:\n        target: The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".\n\n    Returns:\n        A string representing the resolved version or value.\n\n    Raises:\n        ValueError: If the target is not recognized.\n    \"\"\"\n    if target == \"python\":\n        return sys.version.split()[0]\n    if target == \"func_core_tools\":\n        try:\n            output = subprocess.check_output([\"func\", \"--version\"], text=True)\n            return output.strip()\n        except Exception:\n            return \"0.0.0\"  # Return a fallback version if resolution fails\n    raise ValueError(f\"Unknown target: {target}\")\n</code></pre>"},{"location":"api/#utility","title":"Utility","text":""},{"location":"api/#azure_functions_doctor.utils.format_detail","title":"<code>format_detail(status, value)</code>","text":"<p>Return a colored Text element based on status and value.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <code>value</code> <code>str</code> <p>Text to display, typically a description.</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object styled with status color.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_detail(status: str, value: str) -&gt; Text:\n    \"\"\"\n    Return a colored Text element based on status and value.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n        value: Text to display, typically a description.\n\n    Returns:\n        A Rich Text object styled with status color.\n    \"\"\"\n    color = DETAIL_COLOR_MAP.get(status, \"white\")\n    return Text(value, style=color)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_result","title":"<code>format_result(status)</code>","text":"<p>Return a styled icon Text element based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object with icon and style for headers.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_result(status: str) -&gt; Text:\n    \"\"\"\n    Return a styled icon Text element based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A Rich Text object with icon and style for headers.\n    \"\"\"\n    style = STATUS_STYLES.get(status, Style(color=\"white\"))\n    icon = format_status_icon(status)\n    return Text(icon, style=style)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_status_icon","title":"<code>format_status_icon(status)</code>","text":"<p>Return a simple icon character based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string icon such as \u2714, \u2716, or \u26a0.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_status_icon(status: str) -&gt; str:\n    \"\"\"\n    Return a simple icon character based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A string icon such as \u2714, \u2716, or \u26a0.\n    \"\"\"\n    return STATUS_ICONS.get(status, \"?\")\n</code></pre>"},{"location":"development/","title":"\ud83d\udee0\ufe0f Development Guide (Hatch-based)","text":"<p>This project uses Hatch as its build and environment manager.</p>"},{"location":"development/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.9+</li> <li>Git</li> <li>Recommended: <code>uv</code> for fast dependency management</li> </ul>"},{"location":"development/#setup","title":"\ud83d\ude80 Setup","text":"<pre><code>make venv               # Create virtual environment\nmake install            # Install dependencies using Hatch\nmake precommit-install  # Install pre-commit hooks\n</code></pre>"},{"location":"development/#local-testing","title":"\ud83e\uddea Local Testing","text":"<pre><code>make check         # Format, lint, typecheck, test\nmake test          # Run unit tests\nmake cov           # Generate test coverage report\n</code></pre>"},{"location":"development/#release-workflow","title":"\ud83d\udea2 Release Workflow","text":"<pre><code>make release-patch   # Patch version bump + changelog update\nmake release-minor   # Minor version bump + changelog update\nmake release-major   # Major version bump + changelog update\nmake publish         # Publish to PyPI (requires credentials)\n</code></pre>"},{"location":"development/#code-quality-commands","title":"\ud83e\uddf9 Code Quality Commands","text":"<pre><code>make format      # Format code with Black + Ruff\nmake lint        # Run Ruff + Mypy\nmake typecheck   # Run static type checks\nmake docs        # Serve local MkDocs site\n</code></pre>"},{"location":"diagnostics/","title":"Diagnostic Checks","text":"<p>This document lists potential diagnostic features for Azure Functions Doctor, based on Azure Functions Python Reference and Azure Functions Best Practices. </p> # Diagnostic Check Description Feasibility Status 1 Python version \u2265 3.9 Check if the runtime meets minimum requirements \u2705 Easy \u2705 Implemented 2 Virtual environment (.venv) exists Ensure isolation of dependencies \u2705 Easy \u2705 Implemented 3 Azure Functions Core Tools installed Validate that <code>func</code> CLI is available \u2705 Easy \u2705 Implemented 4 host.json exists and is valid Ensure configuration file is present \u2705 Easy \u2705 Implemented 5 function.json exists per function Ensure each function folder has its own function.json \u2705 Easy \u2705 Implemented 6 Directory structure validation Check if directory matches Azure Functions layout \u2705 Easy \u2705 Implemented 7 requirements.txt or pyproject.toml present Check for dependency file \u2705 Easy \ud83d\udd27 Planned 8 local.settings.json exists Verify local dev settings file exists \u2705 Easy \ud83d\udd27 Planned 9 EntryPoint function exists Ensure the entryPoint in function.json matches a real Python function \u2705 Easy \ud83d\udd27 Planned 10 Function name and folder match Ensure function directory and entryPoint are aligned \u2705 Easy \ud83d\udd27 Planned 11 Durable Functions config in host.json Detect durableTask section for durable functions \u2705 Medium \ud83d\udd27 Planned 12 HTTP trigger config validation Validate authLevel, route, and methods \u2705 Medium \ud83d\udd27 Planned 13 Timer trigger CRON expression validation Check CRON format in bindings \u2705 Medium \ud83d\udd27 Planned 14 App Insights configuration Validate instrumentation key or connection string \u2705 Medium \ud83d\udd27 Planned 15 Function mode detection (decorator or json) Detect whether function app uses decorators or function.json model \u2705 Medium \ud83d\udd27 Planned 16 ASGI/WSGI compatibility Check if the app exposes ASGI/WSGI interfaces \u2705 Medium \ud83d\udd27 Planned 17 Detect unused or invalid files Warn about <code>.pyc</code>, <code>__pycache__</code>, or other irrelevant files \u2705 Low \ud83e\udded Possible 18 Detect long-running code patterns Flag suspicious code like <code>time.sleep</code> or infinite loops \u274c Hard \u274c Not feasible 19 Excessive logging Identify overuse of <code>print()</code> or <code>logging.debug()</code> \u274c Runtime \u274c Not feasible 20 Monolith vs modular layout Warn if everything is in one file or single large function \u274c Context \u274c Not feasible <p>Legend: \u2705 Easy = statically checkable \u2705 Medium = requires additional parsing/context \u274c = not feasible by static analysis \ud83d\udd27 Planned = scheduled for future implementation \ud83e\udded Possible = technically feasible but lower priority</p>"},{"location":"release_process/","title":"\ud83d\udee0 Release Process","text":"<p>This document describes how to release a new version of Azure Functions Doctor to PyPI and update the changelog.</p>"},{"location":"release_process/#step-1-update-the-version","title":"\ud83e\uddfe Step 1: Update the Version","text":"<p>Use Hatch to bump the version and generate changelog:</p> <pre><code>make release-patch   # or: release-minor, release-major\n</code></pre> <p>This will:</p> <ul> <li>Update the version in <code>pyproject.toml</code></li> <li>Generate <code>CHANGELOG.md</code> via <code>git-cliff</code></li> <li>Commit changelog</li> <li>Tag the commit (e.g. <code>v0.2.0</code>)</li> <li>Push the tag to GitHub</li> </ul>"},{"location":"release_process/#step-2-publish-to-pypi","title":"\ud83d\udce6 Step 2: Publish to PyPI","text":"<p>Build and upload the package:</p> <pre><code>make build\nmake publish\n</code></pre> <p>This will upload the package to PyPI.</p> <p>\ud83d\udd12 Make sure your <code>~/.pypirc</code> is correctly configured with PyPI credentials.</p>"},{"location":"release_process/#summary","title":"\u2705 Summary","text":"Task Command Version bump + changelog <code>make release-patch</code> Build package <code>make build</code> Publish to PyPI <code>make publish</code>"},{"location":"release_process/#test-on-testpypi-optional","title":"\ud83d\udd01 Test on TestPyPI (Optional)","text":"<pre><code>hatch build\ntwine upload --repository testpypi dist/*\npip install --index-url https://test.pypi.org/simple/ azure-functions-doctor\n</code></pre>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#rulesjson-documentation","title":"\ud83d\udcd8 <code>rules.json</code> Documentation","text":"<p>The <code>rules.json</code> file defines diagnostic checks declaratively for Azure Functions Doctor. Each rule specifies what to validate, how to validate it, and what to show when the check passes or fails \u2014 without modifying the core Python code.</p> <p>This makes the tool extensible and customizable.</p>"},{"location":"rules/#location","title":"\ud83d\udcc1 Location","text":"<p>The file is located at the project root:</p> <pre><code>azure-functions-doctor/\n\u251c\u2500\u2500 rules.json  \ud83d\udc48\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 azure_functions_doctor/\n</code></pre>"},{"location":"rules/#structure-of-a-rule","title":"\u2310 Structure of a Rule","text":"<p>Each rule is a JSON object with the following fields:</p> <pre><code>{\n  \"id\": \"check_python_version\",\n  \"section\": \"python_env\",\n  \"label\": \"Python version\",\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\",\n  \"hint\": \"Install Python 3.9 or higher.\"\n}\n</code></pre>"},{"location":"rules/#fields-explained","title":"\ud83d\udd11 Fields Explained","text":"Field Type Description <code>id</code> string Unique identifier for the rule <code>section</code> string Logical group (e.g. <code>python_env</code>, <code>config_files</code>) <code>label</code> string Human-readable label for the check <code>type</code> string Rule type (see below) <code>target</code> string Subject to evaluate (e.g. Python version, file path) <code>operator</code> string Comparison operator (e.g. <code>==</code>, <code>!=</code>, <code>&gt;=</code>) <code>value</code> any Expected value to compare <code>hint</code> string Suggestion if the rule fails"},{"location":"rules/#supported-rule-types","title":"\ud83d\udd0d Supported Rule Types","text":""},{"location":"rules/#1-compare_version","title":"1. <code>compare_version</code>","text":"<p>Compare semantic versions.</p> <pre><code>{\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\"\n}\n</code></pre> <ul> <li>Valid <code>target</code>: <code>\"python\"</code>, <code>\"azure-functions-core-tools\"</code></li> </ul>"},{"location":"rules/#2-file_exists","title":"2. <code>file_exists</code>","text":"<p>Check whether a file exists.</p> <pre><code>{\n  \"type\": \"file_exists\",\n  \"target\": \"host.json\"\n}\n</code></pre>"},{"location":"rules/#3-file_contains","title":"3. <code>file_contains</code>","text":"<p>Check whether a file contains a specific string or key path.</p> <pre><code>{\n  \"type\": \"file_contains\",\n  \"target\": \"host.json\",\n  \"key_path\": [\"version\"],\n  \"value\": \"2.0\"\n}\n</code></pre>"},{"location":"rules/#4-custom","title":"4. <code>custom</code>","text":"<p>You may register custom handlers in code using the <code>@handler.register(\"your_type\")</code> decorator.</p>"},{"location":"rules/#grouping-by-section","title":"\ud83d\udcc1 Grouping by <code>section</code>","text":"<p>Sections allow grouping related checks together for better readability in the CLI output:</p> <p>Example:</p> <pre><code>{\n  \"section\": \"python_env\",\n  \"label\": \"Python Version\",\n  ...\n}\n</code></pre> <p>Predefined sections might include:</p> <ul> <li><code>python_env</code></li> <li><code>core_tools</code></li> <li><code>config_files</code></li> <li><code>dependencies</code></li> <li><code>network</code></li> </ul> <p>You can create your own section names if desired.</p>"},{"location":"rules/#extending-the-rules","title":"\ud83e\uddf9 Extending the Rules","text":"<p>To add a new rule:</p> <ol> <li>Open <code>rules.json</code></li> <li>Append your rule object to the array</li> <li>Save and rerun <code>azfunc-doctor</code></li> </ol> <p>Example:</p> <pre><code>{\n  \"id\": \"check_requirements_txt_exists\",\n  \"section\": \"dependencies\",\n  \"label\": \"requirements.txt exists\",\n  \"type\": \"file_exists\",\n  \"target\": \"requirements.txt\",\n  \"hint\": \"Create a requirements.txt file to declare Python dependencies.\"\n}\n</code></pre>"},{"location":"rules/#tips","title":"\ud83d\udee0\ufe0f Tips","text":"<ul> <li>Use <code>hint</code> to provide helpful, actionable suggestions.</li> <li>Use consistent <code>section</code> names for better CLI grouping.</li> <li>If you're writing custom rule types, register them in <code>handlers.py</code>.</li> </ul>"},{"location":"rules/#testing-your-changes","title":"\ud83e\udd6a Testing Your Changes","text":"<p>After editing <code>rules.json</code>, you can run:</p> <pre><code>azfunc-doctor diagnose --verbose\n</code></pre> <p>To see grouped results and hints.</p>"},{"location":"rules/#example-rulesjson-simplified","title":"\ud83d\udcdf Example rules.json (simplified)","text":"<pre><code>[\n  {\n    \"id\": \"check_python_version\",\n    \"section\": \"python_env\",\n    \"label\": \"Python version\",\n    \"type\": \"compare_version\",\n    \"target\": \"python\",\n    \"operator\": \"&gt;=\",\n    \"value\": \"3.9\",\n    \"hint\": \"Install Python 3.9 or higher.\"\n  },\n  {\n    \"id\": \"check_host_json_exists\",\n    \"section\": \"config_files\",\n    \"label\": \"host.json exists\",\n    \"type\": \"file_exists\",\n    \"target\": \"host.json\"\n  }\n]\n</code></pre>"},{"location":"rules/#contribute-new-rules","title":"\ud83d\udcec Contribute New Rules","text":"<p>Want to improve the default rules? Feel free to open a PR or discussion on \ud83d\udc49 GitHub Repository</p>"},{"location":"usage/","title":"\ud83d\udda5\ufe0f CLI Usage: Azure Functions Doctor","text":"<p>Azure Functions Doctor provides a command-line interface (CLI) to validate and troubleshoot your Python Azure Functions project setup.</p>"},{"location":"usage/#basic-usage","title":"\ud83d\udd27 Basic Usage","text":"<p>Run the CLI from your terminal using:</p> <pre><code>azfunc-doctor diagnose\n</code></pre> <p>You can also specify options:</p> <pre><code>azfunc-doctor diagnose --format json --verbose\n</code></pre>"},{"location":"usage/#what-it-checks","title":"\ud83e\ude7a What It Checks","text":"<ul> <li>\u2705 Python version is \u2265 3.9</li> <li>\u2705 Virtual environment is activated (VIRTUAL_ENV)</li> <li>\u2705 Python executable path is resolvable</li> <li>\u2705 <code>requirements.txt</code> file exists</li> <li>\u2705 <code>azure-functions</code> package is installed</li> <li>\u2705 Project files like <code>host.json</code>, <code>local.settings.json</code>, and <code>main.py</code> exist</li> </ul>"},{"location":"usage/#example-output","title":"\ud83d\udca1 Example Output","text":"<pre><code>\ud83e\ude7a Azure Functions Doctor for Python v0.1.0\n\ud83d\udcc1 Path: /root/Github/azure-functions-doctor/examples/basic-hello\n\n\u2716 Python Env\n  \u2022 Python version: Python version is 3.12.3, expected &gt;=3.9\n  \u2022 Virtual environment: VIRTUAL_ENV is set\n  \u2022 Python executable: /root/.local/share/hatch/env/virtual/azure-functions-doctor/qaLwoID5/azure-functions-doctor/bin/python exists\n  \u2022 requirements.txt: /root/Github/azure-functions-doctor/examples/basic-hello/requirements.txt exists\n  \u2022 azure-functions package: Package 'azure_functions' is not installed\n\n\u2716 Project Structure\n  \u2022 host.json: /root/Github/azure-functions-doctor/examples/basic-hello/host.json exists\n  \u2022 local.settings.json: /root/Github/azure-functions-doctor/examples/basic-hello/local.settings.json is missing\n  \u2022 main.py: /root/Github/azure-functions-doctor/examples/basic-hello/main.py is missing\n\nSummary\n\u2714 0 Passed    \u2716 2 Failed\n</code></pre>"},{"location":"usage/#help","title":"\ud83c\udd98 Help","text":"<p>To view available options and subcommands:</p> <pre><code>azfunc-doctor --help\nazfunc-doctor diagnose --help\n</code></pre>"}]}